# Lossless Data Compression Toolkit for MATLAB

Done for the MATLAB course at Georgia State University by Ethan Bovard, Nate Evarts, and Neil Nguyen in the Spring 2021 semester. This MATLAB-built class toolkit includes multiple classes that are commonly used for lossless data compression. Since this project is open source, any of these algorithms can be modified to compress data of any kind.

Some algorithms may incorporate Java libraries (i.e. from java.lang or java.util). Example uses include ArrayLists or StringBuffers, to make sure everything was done by the book.

# Sweet! How do I start?
Each algorithm is stored in their own class, and their accompanying encode and decode functions are static, which makes it easy to code into your own project. For example, if we wanted to use that neat Huffman coding algorithm to compress our string, this is how you would go on about it:
```
encoded_string = huffman.encode("test");
decoded_string = huffman.decode(encode_string);
```
The process is the same for the other algorithms supported in the toolkit. Auxiliary functions and classes (i.e. in Huffman coding) were made or built from other existing solutions to aid the encoding and decoding process. Be sure every helper class file is with the principal class file.

# Compression algorithms supported

* Huffman coding
* Lempel-Ziv-Welch (LZW) compression
* Run-length encoding

## Huffman coding

This MATLAB implementation supports encoding and decoding strings. The encoding process involves an adaptation of the Rosetta Code Java implementation of the same algorithm (which will be referred to below).  It encodes the string using a PriorityQueue, that sorts elements based on each character's frequency, and they end up as leaves. These leaves will then be used to build up the Huffman tree, and in the process their prefix codes set in binary. In the decoding process, these prefix codes are used to traverse through the tree (i.e. 0 is left, 1 is right).

## Lempel-Ziv-Welch (LZW)

Also based on a Rosetta Code implementation made in Java. Encoding involves, in lieu of a dictionary that of conventional programming languages today, a Map object in MATLAB which serves as a code table. It compresses a string to a list of output symbols (or their ASCII values), and decompresses it by also initializing another code table, and using the previous list generated by the encoding function to get the original string.

## Run-length encoding

A string can be compressed using the RLE algorithm by counting the consecutive frequency of each character in a string, and appending it to the output. Decoding it involves enumerating each character in the encoded string, as well as their counts, and write them out as they were.

# Resources used

Whew, that should cover about everything. Below are resources found online that helped us replicate each compression algorithm into MATLAB.

| For | Link |
|--|--|
| Huffman coding | https://rosettacode.org/wiki/Huffman_coding#Java |
| LZW encoding | https://rosettacode.org/wiki/LZW_compression#Java |
| PriorityQueue (for Huffman) | https://www.mathworks.com/matlabcentral/fileexchange/23354-queue |